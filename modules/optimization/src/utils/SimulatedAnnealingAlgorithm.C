//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "SimulatedAnnealingAlgorithm.h"
#include <limits>

// The vector_hash struct
struct vector_hash
{
  template <class T1>
  std::size_t operator()(const std::vector<T1> & vector) const
  {
    std::size_t seed = vector.size();
    for (auto & i : vector)
    {
      seed ^= i + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }
    return seed;
  }
};

SimulatedAnnealingAlgorithm::SimulatedAnnealingAlgorithm()
  : CustomOptimizationAlgorithm(),
    _alpha(1e-2),
    _temp_max(100.0),
    _temp_min(0.01),
    _min_objective(std::numeric_limits<Real>::max()),
    _cooling(trial), /*    LinMult, ExpMult, LogMult, QuadMult, LinAdd, QuadAdd, ExpAdd, TrigAdd */
    _monotonic_cooling(false), /* Whether cooling is monotonic or not */
    _res_var(1), /*the initial temperature to start resetting the current state to the best found
                       state when this temperature is reached. This temperature is halved every-time
                       it is reached.*/
    _num_swaps(1),
    _num_reassignments(0),
    _real_perturbation_type(RandomDirectionStretching),
    _relative_perturbation(0.05),
    _upper_limit_provided(false),
    _lower_limit_provided(false)
{
}

void
SimulatedAnnealingAlgorithm::solve()
{
  // check that solution size has been set
  if (_size == 0)
    mooseError("Solution size is zero. Most likely setInitialSolution was not called.");

  // check neighbor generation options for int params
  if (_int_state_size > 0 && _num_reassignments > 0 && _valid_options.size() < 2)
    mooseError("If the number of reassignments for neigbor generation is > 0, then the number of "
               "valid options must be at least 2.");

  if (_int_state_size > 0 && _num_swaps + _num_reassignments == 0)
    mooseError("The problem has a non-zero number of categorical parameters, but the number of "
               "swaps and number of reassignments for neighbor generation are both 0.");

  // set neighbor & best states
  std::vector<Real> neighbor_real_solution = _current_real_solution;
  std::vector<int> neighbor_int_solution = _current_int_solution;
  std::vector<Real> best_real_solution = _current_real_solution;
  std::vector<int> best_int_solution = _current_int_solution;
  Real current_objective;
  objectiveFunction(current_objective, _current_real_solution, _current_int_solution, _ctx);

  _min_objective = current_objective; // Minimum objective is e_best in the fortran code

  Real temp_current = _temp_max;      // Current temperature is set to maximum one.

  // the number of "accepted" steps [not necessarily equal to # of traversals of while loop]
  _it_counter = 0;

  // Sets the seed for the random number generator
  MooseRandom::seed(std::time(0));

  // Keeping track of the accepted solutions!
  // This initializes with 3 pairs, each having a maximum possible objective value and an empty
  // vector of integers
  std::vector<std::pair<Real, std::vector<int>>> solutions(
      3, std::make_pair(std::numeric_limits<Real>::max(), std::vector<int>()));

  // Tabu list
  std::deque<std::vector<int>> tabu_list;
  const int max_tabu_size = 333; // maximum size of the Tabu list

  // Solution cache
  std::unordered_map<std::vector<int>, Real, vector_hash> solution_cache;

  // Define a vector to store all accepted solutions and their objective values
  // std::vector<std::pair<Real, std::vector<int>>> all_accepted_solutions;

  // simulated annealing loop
  while (_it_counter < _max_its && temp_current > _temp_min)
  {

    // Sets the seed for the random number generator
    // std::srand(std::time(0));
    // MooseRandom::seed(std::time(0) + _it_counter);

    // get a new neighbor and compute energy
    createNeigborReal(_current_real_solution, neighbor_real_solution);
    createNeigborInt(_current_int_solution, neighbor_int_solution);

    // Check if neighbor is in Tabu list
    if (std::find(tabu_list.begin(), tabu_list.end(), neighbor_int_solution) != tabu_list.end())
    {
      // Neighbor is in Tabu list, skip this iteration
      continue;
    }

    Real neigh_objective;

    auto it = solution_cache.find(neighbor_int_solution);
    if (it != solution_cache.end())
    {
      // If the solution is in the cache, use the cached objective value
      neigh_objective = it->second;
    }
    else
    {
      // Otherwise, compute the objective value and add it to the cache
      objectiveFunction(neigh_objective, neighbor_real_solution, neighbor_int_solution, _ctx);
      solution_cache[neighbor_int_solution] = neigh_objective;
    }

    // objectiveFunction(neigh_objective, neighbor_real_solution, neighbor_int_solution, _ctx);

    std::cout << "Here is the neighbour objective value:  " << neigh_objective << " !\n\n\n";
    std::cout << "Here is the current objective value:  " << current_objective << " !\n\n\n";

    // Copy the current solution
    std::vector<int> current_int_solution_copy = _current_int_solution;

    // acceptance check: lower objective always accepted;
    // acceptance check: lower temps always accepted;
    // higher objective sometimes accepted
    Real temp_r = MooseRandom::rand();
    if (temp_r <= acceptProbability(current_objective, neigh_objective, temp_current))
    {
      // if we accept then it always counts as a new step
      ++_it_counter;
      _current_real_solution = neighbor_real_solution;
      _current_int_solution = neighbor_int_solution;
      current_objective = neigh_objective;

      // Add the current solution to the Tabu list
      tabu_list.push_back(_current_int_solution);

      // If the Tabu list is too big, remove the oldest element
      if (tabu_list.size() > max_tabu_size)
      {
        tabu_list.pop_front();
      }

      std::cout << "IN THIS STEP, WE ACCEPTED THE SOLUTION!"
                << "\n\n\n";
      std::cout << "The current Objective value is: " << current_objective << "!\n";
      std::cout << "The neighbor Objective value is: " << neigh_objective << "!\n";
    }
    else
    {
      // otherwise, it has a 50% chance to count as a new step to finish the problem
      // this is especially important for combinatorial problems
      Real temp_rr = MooseRandom::rand();
      if (temp_rr <= 0.25)
        ++_it_counter;

      std::cout << "IN THIS STEP, WE DID NOT ACCEPT!"
                << "\n\n\n";
    }

    // cool the temperature
    temp_current = coolingSchedule(_it_counter);

    // if this is the best energy, it's our new best value
    if (current_objective < _min_objective)
    {
      _min_objective = current_objective;
      best_real_solution = _current_real_solution;
      // best_int_solution = _current_int_solution;
      best_int_solution = current_int_solution_copy;

      // Each time you find a better solution, add it to the vector
      solutions.push_back(std::make_pair(_min_objective, best_int_solution));

      // // Find the pair with the worst objective value
      // // Here we are using the iterators functionality in C++
      auto worst_it = std::max_element(solutions.begin(), solutions.end());

      // // If the current objective is better than the worst stored one, replace it
      if (current_objective < worst_it->first)
      {
        *worst_it = std::make_pair(_min_objective, best_int_solution);
      }

      // all_accepted_solutions.push_back(std::make_pair(_min_objective, best_int_solution));
    }

    // perform non-monotonic adjustment if applicable
    if (!_monotonic_cooling)
      temp_current *= (1.0 + (current_objective - _min_objective) / current_objective);

    // rewind to best value if reset is enabled
    if (std::abs(temp_current) <= _res_var)
    {
      _res_var *= 0.5;
      current_objective = _min_objective;
      _current_real_solution = best_real_solution;
      _current_int_solution = best_int_solution;
    }
  }

  // select the best state we ended up finding
  current_objective = _min_objective;
  _current_real_solution = best_real_solution;
  _current_int_solution = best_int_solution;

  // Add the ultimate best solution to the vector
  solutions.push_back(std::make_pair(current_objective, _current_int_solution));

  // // Find the pair with the worst objective value
  // // Here we are using the iterators functionality in C++
  auto worst_it = std::max_element(solutions.begin(), solutions.end());

  // // If the current objective is better than the worst stored one, replace it
  if (current_objective < worst_it->first)
  {
    *worst_it = std::make_pair(current_objective, _current_int_solution);
  }

  // Now sort the vector
  // std::sort(solutions.begin(), solutions.end());
  // std::sort(all_accepted_solutions.begin(), all_accepted_solutions.end());

  // Insert the best 3 solutions into the solutions vector
  // for (std::size_t i = 0; i < 3 && i < all_accepted_solutions.size(); i++)
  // {
  //   solutions[i] = all_accepted_solutions[i];
  // }

  // The best solution is the first one after sorting
  std::sort(solutions.begin(), solutions.end());
  std::pair<Real, std::vector<int>> best_pair = solutions[0];

  // Print the best solution and its objective value
  std::cout << "Best objective value: " << best_pair.first << "\n";
  std::cout << "Associated solution: ";
  for (int value : best_pair.second)
  {
    std::cout << value << " ";
  }
  std::cout << "\n";
}

Real
SimulatedAnnealingAlgorithm::coolingSchedule(unsigned int step) const
{

  auto fraction = (((Real)_max_its - (Real)step) / (Real)_max_its);

  switch (_cooling)
  {
    case LinAdd:
      return _temp_min + (_temp_max - _temp_min) * fraction;

    case ExpMult:
      return _temp_max * std::pow(_alpha, step);

    case QuadAdd:
      return _temp_min + (_temp_max - _temp_min) * std::pow(fraction, 2);
    case trial:
      return _temp_max * std::pow(_temp_min / _temp_max, (Real)step / (Real)_max_its);

    default:
      ::mooseError("Cooling option not yet implemented! Please choose from the follwoing options: "
                   "LinMult, ExpMult, LogMult, QuadMult, LinAdd, QuadAdd, ExpAdd, TrigAdd");
  }

  return 1;
}

void
SimulatedAnnealingAlgorithm::createNeigborReal(const std::vector<Real> & real_sol,
                                               std::vector<Real> & real_neigh) const
{
  if (_real_size == 0)
  {
    real_neigh = {};
    return;
  }

  Real norm = 0;
  for (auto & p : real_sol)
    norm += p * p;
  norm = std::sqrt(norm);

  switch (_real_perturbation_type)
  {
    case RandomDirectionStretching:
      // we need to loop until we find a perturbation
      // that does not violate the parameter limits
      while (true)
      {
        Real norm_perturbation = norm * _relative_perturbation * MooseRandom::randNormal(0.0, 1.0);
        std::vector<Real> dir;
        randomDirection(_real_size, dir);

        bool accept = true;
        for (unsigned int j = 0; j < _real_size; ++j)
        {
          real_neigh[j] = real_sol[j] + norm_perturbation * dir[j];

          if (_upper_limit_provided && real_neigh[j] > _parameter_upper_limit[j])
            accept = false;

          if (_lower_limit_provided && real_neigh[j] < _parameter_lower_limit[j])
            accept = false;

          if (!accept)
            break;
        }

        if (accept)
          return;
      }
      break;
    case BoxSampling:
      if (!_upper_limit_provided || !_lower_limit_provided)
        mooseError("Upper and lower limits must be provided for BoxSampling");

      for (unsigned int j = 0; j < _real_size; ++j)
        real_neigh[j] =
            _parameter_lower_limit[j] +
            MooseRandom::rand() * (_parameter_upper_limit[j] - _parameter_lower_limit[j]);
      break;
    default:
      mooseError("Unrecognized neigbor perturation selection");
  }
}

void
SimulatedAnnealingAlgorithm::createNeigborInt(const std::vector<int> & int_sol,
                                              std::vector<int> & int_neigh) const
{
  // Logging the size of the integer solution
  std::cout << "Size of the integer solution: " << _int_size << std::endl;

  // // SEEMS TO BE WORKING!!
  if (_int_size == 0)
  {
    int_neigh = {};
    return;
  }
  unsigned int index = MooseRandom::randl() % _int_size;
  int_neigh = int_sol;
  // Flip the value at the chosen index (change 1 to 2 or vice versa)
  if (int_neigh[index] == 1)
  {
    int_neigh[index] = 2;
  }
  else
  {
    int_neigh[index] = 1;
  }

  // if (_int_size == 0)
  // {
  //   int_neigh = {};
  //   return;
  // }

  // // set neighbor to the current state
  // int_neigh = int_sol;

  // // Define the number of mutations
  // unsigned int num_mutations = 7; // Feel free to adjust this value

  // for (unsigned int i = 0; i < num_mutations; ++i)
  // {
  //   // Choose a random index
  //   unsigned int index = MooseRandom::randl() % _int_size;

  //   // Increment the value at the chosen index, wrap around to 1 if it's 2
  //   if (int_neigh[index] == 1)
  //   {
  //     int_neigh[index] = 2;
  //   }
  //   else
  //   {
  //     int_neigh[index] = 1;
  //   }
  // }

  // Check to make sure the domain contains at least one type of each material
  bool hasOne = false, hasTwo = false;
  for (unsigned int i = 0; i < _int_size; ++i)
  {
    if (int_neigh[i] == 1)
    {
      hasOne = true;
    }
    else if (int_neigh[i] == 2)
    {
      hasTwo = true;
    }

    // If both materials are found, break the loop early
    if (hasOne && hasTwo)
      break;
  }

  // If either material is missing, insert it at a random position
  if (!hasOne || !hasTwo)
  {
    int_neigh[MooseRandom::randl() % _int_size] = !hasOne ? 1 : 2;
  }

  // int diff = 0;
  // while (diff < 1)
  // {
  //   for (unsigned int j = 0; j < _num_swaps; ++j)
  //   {
  //     auto j1 = MooseRandom::randl() % _int_size;
  //     auto j2 = MooseRandom::randl() % _int_size;

  //     // Logging the indices chosen for swapping
  //     std::cout << "Indices chosen for swapping: " << j1 << ", " << j2 << std::endl;

  //     mooseAssert(j1 < _int_size, "The index needs to be smaller than integer size");
  //     mooseAssert(j2 < _int_size, "The index needs to be smaller than integer size");

  //     int_neigh[j1] = int_sol[j2];
  //     int_neigh[j2] = int_sol[j1];
  //   }

  //   for (unsigned int j = 0; j < _num_reassignments; ++j)
  //   {
  //     if (_valid_options.size() == 0)
  //     {
  //       mooseError("The number of reassignments is > 0, but no valid options for the "
  //                  "integer/categorical parameters was provided.");
  //     }
  //     auto j1 = MooseRandom::randl() % _int_size;
  //     auto j2 = MooseRandom::randl() % _valid_options.size();

  //     // Logging the indices chosen for reassignment
  //     std::cout << "Indices chosen for reassignment: " << j1 << ", " << j2 << std::endl;

  //     mooseAssert(j1 < _int_size, "The index needs to be smaller than integer size");
  //     mooseAssert(j2 < _valid_options.size(),
  //                 "The index needs to be smaller than valid options size");

  //     int_neigh[j1] = _valid_options[j2];
  //   }

  //   diff = 0;
  //   for (unsigned int j = 0; j < _int_size; ++j)
  //   {
  //     diff += std::abs(int_neigh[j] - int_sol[j]);
  //   }

  //   // Logging the computed difference
  //   std::cout << "Computed difference: " << diff << std::endl;
  // }
}

Real
SimulatedAnnealingAlgorithm::acceptProbability(Real curr_obj, Real neigh_obj, Real curr_temp) const
{

  // Metropolis criterion
  Real delta_obj = neigh_obj - curr_obj;
  Real aprob;
  if (-delta_obj / curr_temp <= -700.0)
    aprob = 0.0;
  else if (-delta_obj / curr_temp >= 700.0)
    aprob = 1.0;
  else
    // aprob = std::exp(-delta_obj / curr_temp);
    aprob = std::exp(-delta_obj / curr_temp);

  if (delta_obj <= 0.0)
    aprob = 1.0;

  if (std::isnan(aprob))
    aprob = 0.0;
  return aprob;
}

void
SimulatedAnnealingAlgorithm::setValidReassignmentOptions(const std::set<int> & options)
{
  if (options.size() == 0)
    mooseError("Empty set of options");
  _valid_options.clear();
  _valid_options.resize(options.size());
  unsigned int j = 0;
  for (auto & p : options)
    _valid_options[j++] = p;
}

void
SimulatedAnnealingAlgorithm::setLowerLimits(const std::vector<Real> & lower_limits)
{
  _lower_limit_provided = true;
  _parameter_lower_limit = lower_limits;
  if (_parameter_lower_limit.size() != _real_size)
    mooseError("Lower limits has incorrect size");
}

void
SimulatedAnnealingAlgorithm::setUpperLimits(const std::vector<Real> & upper_limits)
{
  _upper_limit_provided = true;
  _parameter_upper_limit = upper_limits;
  if (_parameter_upper_limit.size() != _real_size)
    mooseError("Upper limits has incorrect size");
}

// Muller & Marsaglia (‘Normalized Gaussians’)
void
SimulatedAnnealingAlgorithm::randomDirection(unsigned int size, std::vector<Real> & direction) const
{
  direction.resize(size);

  // set direction to a vector normally distributed random variables
  for (unsigned int j = 0; j < size; ++j)
    direction[j] = MooseRandom::randNormal(0.0, 1.0);

  // compute the norm of direction
  Real norm = 0.0;
  for (auto & p : direction)
    norm += p * p;
  norm = std::sqrt(norm);

  // normalize
  for (unsigned int j = 0; j < size; ++j)
    direction[j] /= norm;
}
